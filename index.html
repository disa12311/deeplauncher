<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Minecraft Launcher</title>
  <meta name="description" content="Launcher demo kết nối với game_engine wasm / fallback JS" />
  <style>
    :root{
      --bg1:#0f1720;
      --bg2:#1e1e1e;
      --accent1:#3c8dbc;
      --accent2:#4caf50;
      --text:#e6eef6;
      --muted:#bfcbd6;
      --card: rgba(255,255,255,0.02);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
      background:linear-gradient(135deg,var(--bg1),var(--bg2));
      color:var(--text);
      font-family:Segoe UI, Roboto, Arial, sans-serif;
    }
    .container{
      width:100%;
      max-width:820px;
      border-radius:12px;
      padding:20px;
      background:var(--card);
      box-shadow:0 8px 30px rgba(0,0,0,0.6);
      display:flex;
      gap:18px;
      align-items:center;
      justify-content:space-between;
    }
    .left{flex:1;min-width:220px}
    .title{margin:0 0 6px 0;font-size:20px}
    .subtitle{margin:0;color:var(--muted);font-size:13px}
    .controls{display:flex;gap:14px;flex-wrap:wrap;margin-top:12px}
    .btn{padding:12px 28px;border-radius:10px;border:0;cursor:pointer;font-weight:700;min-width:140px}
    .btn:focus{outline:3px solid rgba(60,139,188,0.18);outline-offset:3px}
    .btn.blue{background:linear-gradient(135deg,var(--accent1),#2c6d9c);color:white;box-shadow:0 6px 18px rgba(0,0,0,0.45)}
    .btn.green{background:linear-gradient(135deg,var(--accent2),#2e7d32);color:white;box-shadow:0 6px 18px rgba(0,0,0,0.45)}
    .btn:hover{transform:translateY(-3px);transition:transform 180ms ease}
    .right{width:240px;padding:12px;border-radius:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));border:1px solid rgba(255,255,255,0.02)}
    .muted{color:var(--muted);font-size:13px}
    .overlay{
      position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(2,6,23,0.6);
      z-index:999;backdrop-filter: blur(3px);pointer-events:none;opacity:0;transition:opacity .18s;
    }
    .overlay.show{pointer-events:auto;opacity:1}
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:16px;border-radius:10px;text-align:center;min-width:220px;
      box-shadow:0 10px 30px rgba(0,0,0,0.55);
    }
    .spinner{
      width:44px;height:44px;border-radius:50%;border:4px solid rgba(255,255,255,0.06);border-top-color:var(--accent1);
      animation:spin 1s linear infinite;margin:0 auto 10px;
    }
    @keyframes spin{to{transform:rotate(360deg)}}
    @media (max-width:820px){
      .container{flex-direction:column;align-items:stretch}
      .right{width:100%}
    }
  </style>
</head>
<body>
  <div class="container" role="main" aria-labelledby="title">
    <div class="left">
      <h2 class="title" id="title">Chọn phiên bản Minecraft</h2>
      <p class="subtitle">Nhấn một trong các nút để khởi chạy trong cùng tab.</p>

      <div class="controls" role="group" aria-label="Phiên bản">
        <button class="btn blue" id="btn18" aria-label="Play Minecraft 1.8">Play 1.8</button>
        <button class="btn green" id="btn112" aria-label="Play Minecraft 1.12">Play 1.12</button>
      </div>
    </div>

    <aside class="right" aria-hidden="false">
      <div style="font-weight:700">Launcher</div>
      <div class="muted" style="margin-top:8px">
        Kết nối với <code>game_engine</code> (WASM) nếu có, nếu không sẽ fallback về điều hướng thông thường.
      </div>
      <div style="margin-top:10px">
        <button id="prefetchBtn" class="btn" style="padding:8px 12px;background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);min-width:unset">Prefetch targets</button>
      </div>
    </aside>
  </div>

  <div class="overlay" id="overlay" role="status" aria-live="polite" aria-hidden="true">
    <div class="card" id="overlayCard" role="status" aria-live="polite">
      <div class="spinner" aria-hidden="true"></div>
      <div id="overlayText" style="font-weight:700">Đang khởi chạy...</div>
      <div class="muted" style="margin-top:6px">Nếu trang không chuyển, hãy kiểm tra console hoặc build WASM.</div>
    </div>
  </div>

  <script type="module">
    // index.html (full)
    // - expects wasm-pack output at ./wasm/pkg/game_engine.js (and accompanying .wasm)
    // - functions exported by Rust/WASM (as per game_engine.rs):
    //   wasm_ready, list_versions, get_launch_url, navigate_version, set_launcher_callback, start_engine, version_info

    const overlay = document.getElementById('overlay');
    const overlayText = document.getElementById('overlayText');
    const btn18 = document.getElementById('btn18');
    const btn112 = document.getElementById('btn112');
    const prefetchBtn = document.getElementById('prefetchBtn');

    let GE = null;            // module object (imported)
    let wasmAvailable = false;

    async function tryInitWasm() {
      try {
        // dynamic import the wasm-pack glue. If file not present this will throw and we fallback.
        GE = await import('./wasm/pkg/game_engine.js');
        // wasm-pack usually exports a default function (init). Call it if present.
        if (typeof GE.default === 'function') {
          await GE.default(); // initializes wasm module
        } else if (typeof GE.init === 'function') {
          await GE.init();
        }
        console.log('WASM module loaded.');
        // optional: check readiness function
        if (typeof GE.wasm_ready === 'function') {
          try {
            console.log('WASM says:', GE.wasm_ready());
          } catch(e) { /* ignore */ }
        }
        wasmAvailable = true;

        // register a launcher callback: Rust will call this if it wants JS to perform navigation
        if (typeof GE.set_launcher_callback === 'function') {
          // set_launcher_callback expects a JS function value
          GE.set_launcher_callback((version, url) => {
            // show overlay + tiny animation, then navigate
            showOverlay('Rust yêu cầu mở ' + String(version) + ' — chuyển trong giây lát...');
            // allow UI to update
            setTimeout(() => {
              // defensive: url might be a wasm string or JS value, ensure string
              try {
                window.location.href = String(url);
              } catch(e) {
                // fallback: use get_launch_url if available
                if (typeof GE.get_launch_url === 'function') {
                  const u = GE.get_launch_url(version);
                  window.location.href = String(u);
                } else {
                  console.error('Không thể điều hướng:', e);
                }
              }
            }, 350);
          });
        }
      } catch (err) {
        console.warn('WASM module not available — fallback JS will be used.', err);
        GE = null;
        wasmAvailable = false;
      }
    }

    // initialize (non-blocking)
    tryInitWasm();

    function showOverlay(text) {
      overlayText.textContent = text || 'Đang khởi chạy...';
      overlay.classList.add('show');
      overlay.setAttribute('aria-hidden', 'false');
    }
    function hideOverlay() {
      overlay.classList.remove('show');
      overlay.setAttribute('aria-hidden', 'true');
    }

    async function launch(version) {
      // show overlay + small delay for polish
      showOverlay('Chuẩn bị mở phiên bản ' + version + '...');
      await new Promise(r => setTimeout(r, 250));

      if (wasmAvailable && GE) {
        try {
          // If start_engine exists, call it. It may return a JS object synchronously.
          if (typeof GE.start_engine === 'function') {
            const res = GE.start_engine(version);
            // start_engine may return a JsValue object; wrap with Promise.resolve to handle both sync and async
            const result = await Promise.resolve(res);
            // If a launcher callback was set, Rust likely invoked it and handled navigation.
            // But we handle fallback: if result contains url and no callback triggered, navigate.
            try {
              const status = result?.status ?? result?.get?.('status') ?? null;
              const url = result?.url ?? null;
              if (url && !wasmTriggeredNavigation()) {
                // small delay for UX
                await new Promise(r => setTimeout(r, 120));
                location.href = String(url);
                return;
              }
            } catch (e) {
              // ignore and fallback
            }
            // If no url, try get_launch_url
            if (typeof GE.get_launch_url === 'function') {
              const fallbackUrl = GE.get_launch_url(version);
              await new Promise(r => setTimeout(r, 120));
              location.href = String(fallbackUrl);
              return;
            }
          } else if (typeof GE.get_launch_url === 'function') {
            // no start_engine exposed, use get_launch_url
            const url = GE.get_launch_url(version);
            location.href = String(url);
            return;
          }
        } catch (err) {
          console.warn('WASM call failed, falling back:', err);
        }
      }

      // final fallback: normal navigation
      const plainUrl = version === '1.8' ? 'minecraft_1.8.html' : 'minecraft_1.12.html';
      // brief pause so overlay is visible
      await new Promise(r => setTimeout(r, 120));
      location.href = plainUrl;
    }

    // Heuristic: detect whether Rust callback already triggered navigation.
    // We can't reliably detect cross-call navigation, so return false (conservative).
    function wasmTriggeredNavigation() {
      // Could be improved by setting a flag in callback; for now return false to allow fallback.
      return false;
    }

    btn18.addEventListener('click', () => launch('1.8'));
    btn112.addEventListener('click', () => launch('1.12'));

    // keyboard shortcuts 1 / 2
    window.addEventListener('keydown', (e) => {
      if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA')) return;
      if (e.key === '1') btn18.click();
      if (e.key === '2') btn112.click();
    });

    // prefetch targets (adds rel=prefetch links)
    prefetchBtn.addEventListener('click', () => {
      try {
        const urls = ['minecraft_1.8.html', 'minecraft_1.12.html'];
        urls.forEach(u => {
          const l = document.createElement('link');
          l.rel = 'prefetch';
          l.href = u;
          document.head.appendChild(l);
        });
        prefetchBtn.textContent = 'Đã prefetch';
        prefetchBtn.disabled = true;
      } catch (e) {
        console.warn('Prefetch failed', e);
      }
    });

    // If page is served locally and you want to test WASM quickly:
    // 1) Build wasm-pack: wasm-pack build --target web --out-dir ./wasm/pkg
    // 2) Serve files over HTTP (not file://): e.g. `npx serve .` or `python -m http.server`
  </script>
</body>
</html>
